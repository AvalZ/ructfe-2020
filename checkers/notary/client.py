from contextlib import contextmanager
from dataclasses import dataclass

import requests
from bs4 import BeautifulSoup
from gornilo.models.verdict.verdict_codes import MUMBLE, CORRUPT, DOWN
from requests.exceptions import ConnectionError, HTTPError, RequestException, Timeout


PORT = 17171
REQUESTS_TIMEOUT = 10


@dataclass
class UserInfo:
    username: str = None
    name: str = None
    phone: str = None
    address: str = None
    id: str = None
    password: str = None
    public_key: str = None
    private_key: str = None


@dataclass
class DocumentInfo:
    title: str = None
    text: str = None
    id: str = None
    password: str = None


class CheckFailed(ValueError):
    def __init__(self, verdict, reason):
        self.verdict = verdict
        self.reason = reason


@contextmanager
def check(verdict, phase_name=None, exc_messages=None):
    if exc_messages is None:
        exc_messages = {}
    if isinstance(exc_messages, set):
        exc_messages = {exc_type: None for exc_type in exc_messages}
    exc_types = tuple(exc_messages.keys())

    try:
        yield
    except AssertionError as err:
        e = err
        reason = err.args[0]
    except Exception as err:
        if not isinstance(err, exc_types):
            raise
        e = err
        reason = None
        for exc_type, message in exc_messages.items():
            if isinstance(err, exc_type):
                reason = message
        if reason is None:
            reason = type(err).__name__
    else:
        return

    prefix = ''
    if phase_name is not None:
        prefix = f'Failed while {phase_name}: '
    raise CheckFailed(verdict, prefix + reason) from e


def mumble(phase_name=None, exc_messages=None):
    return check(MUMBLE, phase_name, exc_messages)


def corrupt(phase_name=None, exc_messages=None):
    return check(CORRUPT, phase_name, exc_messages)


def down(phase_name=None, exc_messages=None):
    return check(DOWN, phase_name, exc_messages)


class Parser:
    def __init__(self, content):
        self.soup = BeautifulSoup(content, features='lxml')

    def password(self):
        with mumble(None, {AttributeError: 'Autogenerated password not found'}):
            return self.soup.select_one('div.alert:-soup-contains("password")>strong').text

    def csrf_token(self):
        with mumble('extracting the csrf token', {TypeError, KeyError}):
            return self.soup.find('input', dict(name='csrf_token'))['value']

    def user_id(self):
        with mumble('extracting the profile url', {TypeError, KeyError}):
            url = self.soup.select_one('a.nav-link:-soup-contains("Profile")')['href']
        with mumble():
            user_id = url.split('/')[-1]
            assert user_id, 'Could not parse user id from the profile url'
            return user_id

    def profile_field(self, label, code_wrapped=False):
        with mumble(f'extracting user\'s {label.lower()} from the profile page', {AttributeError, IndexError}):
            selector = f'div:has(>strong:-soup-contains("{label}"))'
            if code_wrapped:
                return self.soup.select_one(selector + '>code').text
            return self.soup.select_one(selector).contents[-1][2:].strip()

    def user_info(self, **additional_fields):
        name = self.profile_field('Name')
        phone = self.profile_field('Phone')
        address = self.profile_field('Address')
        public_key = self.profile_field('Public key', code_wrapped=True)
        private_key = self.profile_field('Private key', code_wrapped=True)
        return UserInfo(
            **additional_fields,
            name=name, phone=phone, address=address, public_key=public_key, private_key=private_key)

    def document_info(self, **additional_fields):
        with mumble(f'extracting the title from the document page', {AttributeError}):
            title = self.soup.select_one('.card-header>a').text.strip()
        text = None
        if not self.soup.find('form label:-soup-contains("password")'):
            with mumble(f'extracting the text from the document page', {AttributeError}):
                text = self.soup.select_one('.card-body>p').text.strip()
        return DocumentInfo(
            **additional_fields,
            title=title, text=text)

    @classmethod
    def id_from_url(cls, url):
        with mumble():
            id = url.rsplit('/', 1)[-1]
            assert id, 'Could not parse id from the url'
            return id

@dataclass
class Urls:
    login: str = 'login'
    signup: str = 'signup'
    user: str = 'user/{id}'
    feed: str = ''
    doc: str = 'doc/{id}'
    sign: str = 'sign'
    verify: str = 'verify'

    def __init__(self, hostname):
        base = f'http://{hostname}:{PORT}/'
        for key, field in type(self).__dataclass_fields__.items():
            value = base + field.default
            setattr(self, key, value)


class Client:
    def __init__(self, hostname):
        self.urls = Urls(hostname)
        self.sess = requests.Session()

    def _request(self, method, url, data=None):
        with mumble(None, {RequestException: 'An error occurred while making the request'}):
            with down('connecting to your server', {Timeout, ConnectionError}):
                resp = self.sess.request(method, url, data=data, timeout=REQUESTS_TIMEOUT)
        with mumble(None, {HTTPError: 'Unexpected HTTP return code'}):
            resp.raise_for_status()
        return resp

    def _load_token(self, url):
        resp = self._request('GET', url)
        return Parser(resp.content).csrf_token()

    def _send_form(self, url, data):
        token = self._load_token(url)
        return self._request('POST', url, data=dict(csrf_token=token, **data))

    def _load_page(self, url):
        return self._request('GET', url)

    def register(self, username, name, phone, address):
        resp = self._send_form(self.urls.signup, data=dict(
            username=username, name=name, phone=phone, address=address))
        parser = Parser(resp.content)
        return parser.user_info(
            username=username,
            password=parser.password(),
            id=parser.id_from_url(resp.url))

    def log_in(self, username, password):
        resp = self._send_form(self.urls.login, data=dict(username=username, password=password))
        user_id = Parser.id_from_url(resp.url)
        return Parser(resp.content).user_info(username=username, password=password, id=user_id)

    def user_id(self):
        content = self._load_page(self.urls.sign).content
        return Parser(content).user_id()

    def user(self, user_id=None):
        if user_id is None:
            user_id = self.user_id()
        return self._load_page(self.urls.user.format(id=user_id)).content

    def feed(self):
        return self._load_page(self.urls.feed).content

    def doc(self, doc_id, password=None):
        url = self.urls.doc.format(id=doc_id)
        if password is None:
            page = self._load_page(url).content
        else:
            page = self._send_form(url, data=dict(password=password)).content
        return Parser(page).document_info(id=doc_id, password=password)

    def sign(self, title, text, public=False):
        data = dict(title=title, text=text)
        if public:
            data['is_public'] = 'on'
        resp = self._send_form(self.urls.sign, data=data)
        doc_id = Parser.id_from_url(resp.url)
        password = None
        if not public:
            password = Parser(resp.content).password()
        return doc_id, password

    def verify(self, title, text, signature, public_key):
        resp = self._send_form(self.urls.verify, data=dict(
            title=title, text=text, signature=signature, public_key=public_key))
        return b'The signature is valid' in resp.content
