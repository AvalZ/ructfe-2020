from dataclasses import dataclass

from bs4 import BeautifulSoup
from requests.exceptions import ConnectionError, HTTPError, RequestException, Timeout

from utils import CONTEXT, DocumentInfo, down, mumble, requests_with_retry, UserInfo


PORT = 17171
REQUESTS_TIMEOUT = 10


class Parser:
    def __init__(self, content):
        self.soup = BeautifulSoup(content, features='lxml')

    def password(self):
        with mumble(None, {AttributeError: 'Autogenerated password not found'}, details=self.soup):
            return self.soup.select_one('div.alert:-soup-contains("password")>strong').text

    def csrf_token(self):
        with mumble('extracting the csrf token', {TypeError, KeyError}, details=self.soup):
            return self.soup.find('input', dict(name='csrf_token'))['value']

    def user_id(self):
        with mumble('extracting the profile url', {TypeError, KeyError}, details=self.soup):
            url = self.soup.select_one('a.nav-link:-soup-contains("Profile")')['href']
        with mumble(details=self.soup):
            user_id = url.split('/')[-1]
            assert user_id, 'Could not parse user id from the profile url'
            return user_id

    def username(self):
        suffix = '\'s profile'
        with mumble(f'extracting username from the profile page', {AttributeError, IndexError}, details=self.soup):
            header = self.soup.select_one(f'h2:-soup-contains("{suffix}")').text.strip()
            assert header.endswith(suffix), 'broken profile header'
            return header[:-len(suffix)]

    def profile_field(self, label, code_wrapped=False):
        try:
            selector = f'div:has(>strong:-soup-contains("{label}"))'
            if code_wrapped:
                return self.soup.select_one(selector + '>code').text
            return self.soup.select_one(selector).contents[-1][2:].strip()
        except (AttributeError, IndexError):
            return None

    def document_ids(self):
        prefix = '/doc/'
        links = self.soup.select(f'a[href^="{prefix}"]')
        return [link['href'][len(prefix):] for link in links]

    def _merge_fields(self, fields, additional_fields, phase_name='checking data consistency'):
        with mumble(phase_name, details=(fields, additional_fields)):
            for key in set(fields.keys()) & set(additional_fields.keys()):
                assert fields[key] == additional_fields[key], f'{key} has an unexpected value'
        return {**fields, **additional_fields}

    def user_info(self, **additional_fields):
        fields = dict(
            username=self.username(),
            name=self.profile_field('Name'),
            phone=self.profile_field('Phone'),
            address=self.profile_field('Address'),
            public_key=self.profile_field('Public key', code_wrapped=True),
            private_key=self.profile_field('Private key', code_wrapped=True),
            document_ids=self.document_ids())
        return UserInfo(**self._merge_fields(fields, additional_fields, 'checking user data consistency'))

    def document_info(self, **additional_fields):
        with mumble(f'extracting the title from the document page', {AttributeError}, details=self.soup):
            title = self.soup.select_one('.card-header>a').text.strip()
        with mumble(f'extracting the author id from the document page', {TypeError, KeyError}, details=self.soup):
            url = self.soup.select_one('p:-soup-contains("Signed by")>a')['href']
            assert url
            author_id = url.split('/')[-1]

        text = None
        signature = None
        if not self.soup.select_one('form label:-soup-contains("Password")'):
            with mumble(f'extracting the text from the document page', {AttributeError}, details=self.soup):
                text = self.soup.select_one('.card-body>p').text.strip()
            with mumble(f'extracting the signature from the document page', {AttributeError}, details=self.soup):
                signature = self.soup.select_one('p:-soup-contains("Document signature")>code').text.strip()

        fields = dict(title=title, text=text, author_id=author_id, signature=signature)
        return DocumentInfo(**self._merge_fields(fields, additional_fields, 'checking document data consistency'))

    @classmethod
    def id_from_url(cls, url):
        with mumble():
            id = url.rsplit('/', 1)[-1]
            assert id, 'Could not parse id from the url'
            return id


@dataclass
class Urls:
    login: str = 'login'
    signup: str = 'signup'
    user: str = 'user/{id}'
    feed: str = ''
    doc: str = 'doc/{id}'
    sign: str = 'sign'
    verify: str = 'verify'

    def __init__(self, hostname):
        base = f'http://{hostname}:{PORT}/'
        for key, field in type(self).__dataclass_fields__.items():
            value = base + field.default
            setattr(self, key, value)


class Client:
    def __init__(self, hostname):
        self.urls = Urls(hostname)
        self.sess = requests_with_retry()

    def _request(self, method, url, data=None):
        with mumble(None, {RequestException: 'An error occurred while making the request'}, details=(url, data)):
            with down('connecting to your server', {Timeout, ConnectionError}, details=(url, data)):
                resp = self.sess.request(method, url, data=data, timeout=REQUESTS_TIMEOUT)
        with mumble(None, {HTTPError: 'Unexpected HTTP return code'}, details=resp.status_code):
            resp.raise_for_status()
        return resp

    def _load_token(self, url):
        resp = self._request('GET', url)
        return Parser(resp.content).csrf_token()

    def _send_form(self, url, data):
        token = self._load_token(url)
        return self._request('POST', url, data=dict(csrf_token=token, **data))

    def _load_page(self, url):
        return self._request('GET', url)

    def register(self, username, name, phone, address) -> UserInfo:
        resp = self._send_form(self.urls.signup, data=dict(
            username=username, name=name, phone=phone, address=address))
        parser = Parser(resp.content)
        password = parser.password()
        CONTEXT.password = password
        return parser.user_info(
            username=username,
            password=password,
            id=parser.id_from_url(resp.url),
            name=name,
            phone=phone,
            address=address)

    def log_in(self, username, password) -> UserInfo:
        resp = self._send_form(self.urls.login, data=dict(username=username, password=password))
        user_id = Parser.id_from_url(resp.url)
        return Parser(resp.content).user_info(username=username, password=password, id=user_id)

    def user_id(self) -> str:
        content = self._load_page(self.urls.sign).content
        return Parser(content).user_id()

    def user(self, user_id=None) -> UserInfo:
        if user_id is None:
            user_id = self.user_id()
        page = self._load_page(self.urls.user.format(id=user_id)).content
        return Parser(page).user_info(id=user_id)

    def feed(self) -> [str]:
        page = self._load_page(self.urls.feed).content
        return Parser(page).document_ids()

    def doc(self, doc_id, password=None) -> DocumentInfo:
        url = self.urls.doc.format(id=doc_id)
        if password is None:
            page = self._load_page(url).content
        else:
            page = self._send_form(url, data=dict(password=password)).content
        return Parser(page).document_info(id=doc_id, password=password)

    def sign(self, title, text, author_id, public=False) -> DocumentInfo:
        data = dict(title=title, text=text)
        if public:
            data['is_public'] = 'on'
        resp = self._send_form(self.urls.sign, data=data)

        doc_id = Parser.id_from_url(resp.url)
        password = None
        if not public:
            password = Parser(resp.content).password()
        return Parser(resp.content).document_info(
            id=doc_id, password=password, title=title, text=text, author_id=author_id)

    def verify(self, title, text, signature, public_key):
        resp = self._send_form(self.urls.verify, data=dict(
            title=title, text=text, signature=signature, public_key=public_key))
        return b'The signature is valid' in resp.content
